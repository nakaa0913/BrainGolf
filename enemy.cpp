//=============================================================================
//
// エネミー処理 [enemy.cpp]
// Author : 
//
//=============================================================================
#include "enemy.h"
#include "texture.h"
#include "sprite.h"


//*****************************************************************************
// マクロ定義
//*****************************************************************************


//*****************************************************************************
// プロトタイプ宣言
//*****************************************************************************


//*****************************************************************************
// グローバル変数
//*****************************************************************************

static ENEMY g_Enemy[ENEMY_MAX];							// エネミー構造体


//=============================================================================
// 初期化処理
//=============================================================================
HRESULT InitEnemy(void)
{
	int texNo = LoadTexture("data/TEXTURE/tako.png");

	// エネミー構造体の初期化
	for (int i = 0; i < ENEMY_MAX; i++)
	{
		g_Enemy[i].use   = false;
		g_Enemy[i].w     = 50.0f;
		g_Enemy[i].h     = 50.0f;
		g_Enemy[i].pos   = D3DXVECTOR2(970.0f+i*15, 300.0f);
		g_Enemy[i].rot   = 0.0f;
		g_Enemy[i].texNo = texNo;
		g_Enemy[i].state = 0;
		g_Enemy[i].frame = 0;
	}
	
	return S_OK;
}

//=============================================================================
// 終了処理
//=============================================================================
void UninitEnemy(void)
{

}

//=============================================================================
// 更新処理
//=============================================================================
void UpdateEnemy(void)
{
	for (int i = 0; i < ENEMY_MAX; i++)
	{
		if (g_Enemy[i].use == true)		// このエネミーが使われている？
		{								// Yes	
			switch (g_Enemy[i].state)
			{
			case 0:
				g_Enemy[i].pos.x -= 3.0f;
				if(g_Enemy[i].frame > 180)
				{
					g_Enemy[i].state = 1;
					g_Enemy[i].frame = 0;
				}
				break;
			case 1:
				g_Enemy[i].pos.x += 3.0f;
				g_Enemy[i].pos.y += 3.0f;

				if (g_Enemy[i].frame > 20)
				{
					g_Enemy[i].state = 2;
					g_Enemy[i].frame = 0;
				}
				break;
			case 2:
				g_Enemy[i].pos.x -= 3.0f;
				if (g_Enemy[i].frame > 40)
				{
					g_Enemy[i].state = 3;
					g_Enemy[i].frame = 0;
				}
				break;
			case 3:
				g_Enemy[i].pos.x += 3.0f;
				g_Enemy[i].pos.y += 3.0f;
				if (g_Enemy[i].frame > 40)
				{
					g_Enemy[i].state = 4;
					g_Enemy[i].frame = 0;
				}
				break;
			case 4:
				g_Enemy[i].pos.x += 3.0f;
				if (g_Enemy[i].frame > 200)
				{
					g_Enemy[i].use = 0;
				}
				break;
			}
									
			// 回転させる
			if ((i % 2) == 0)
			{
				g_Enemy[i].rot += 0.05f;
			}
			else
			{
				g_Enemy[i].rot -= 0.05f;
			}

			//フレームの追加
			g_Enemy[i].frame++;
		}
	}

}

//=============================================================================
// 描画処理
//=============================================================================
void DrawEnemy(void)
{
	for (int i = 0; i < ENEMY_MAX; i++)
	{
		if (g_Enemy[i].use == true)
		{
			//エネミーの位置やテクスチャー座標を反映
			float px = g_Enemy[i].pos.x;	// エネミーの表示位置X
			float py = g_Enemy[i].pos.y;	// エネミーの表示位置Y
			float pw = g_Enemy[i].w;		// エネミーの表示幅
			float ph = g_Enemy[i].h;		// エネミーの表示高さ
			D3DXCOLOR col = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);

			// １枚のポリゴンの頂点とテクスチャ座標を設定
			DrawSpriteColorRotate(g_Enemy[i].texNo, px, py, pw, ph, 0.0f, 0.0f, 1.0f, 1.0f, col, g_Enemy[i].rot);
		}
	}
}

//=============================================================================
// エネミー構造体の先頭アドレスを取得
//=============================================================================
ENEMY *GetEnemy(void)
{
	return &g_Enemy[0];
}


//=============================================================================
// 敵の発生処理
//=============================================================================
void SetEnemy(D3DXVECTOR2 pos)
{
	// もし未使用のデータを探す
	for (int i = 0; i < ENEMY_MAX; i++)
	{
		if (g_Enemy[i].use == false)		// 未使用状態の敵データを見つける
		{
			g_Enemy[i].use = true;			// 使用状態へ変更する
			g_Enemy[i].pos = pos;			// 座標をセット
			g_Enemy[i].rot = 0.0f;			// 回転角のリセット
			g_Enemy[i].state = 0;			// 状態をリセット
			g_Enemy[i].frame = 0;			// フレームのリセット
			return;							// 敵をセットできたので終了する
		}
	}
}

